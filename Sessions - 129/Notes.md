# Log4j 2.x with Spring Boot

Certainly! Here's a detailed explanation of each point you mentioned:

**Logging Service**:
The logging service in a Spring Boot application is responsible for capturing and storing various types of log messages generated by the application. It is typically used in production environments to monitor and diagnose the application's behavior. The logging service provides a centralized location for managing and retrieving log messages.

**Types of Messages**:
In a Spring Boot application, log messages can be categorized into different types such as success, warning, information, exception, and more. These types allow for better organization and filtering of log messages based on their severity and purpose. Each type corresponds to a specific level of log messages.

**Logger with Priority Methods**:
A logger is a component used for writing log messages to various appenders. In Log4j 2.x, the logger is typically created inside the class that generates the log messages. The logger provides methods for logging messages at different log levels or priorities, such as debug(), info(), warn(), error(), and fatal().

The priority methods have a specific order associated with them, indicating their priority or severity. The order of the methods is as follows: debug(), info(), warn(), error(), and fatal(). This order helps determine the severity of log messages and assists in filtering and managing them.

**Appender and Layout Configuration**:
In Log4j 2.x, the appender is responsible for determining where the log messages will be written. Different types of appenders are available to write log messages to various destinations. Some commonly used appenders are ConsoleAppender, FileAppender (writes to a file), JDBCAppender (writes to a database), and SmtpAppender (sends log messages via email).

The layout, on the other hand, determines the format and structure of the log messages. It specifies how the log message should be presented, including information such as date, time, method, class, and message. Log4j 2.x supports different layout formats, such as PatternLayout, XMLLayout, HTMLLayout, and more.

Both the appender and layout can be configured using either an XML or properties file, depending on your preference and requirements.

**PatternLayout**:
PatternLayout is a layout in Log4j 2.x that allows you to define a pattern specifying the desired format of log messages. The pattern can include placeholders or conversion characters representing various elements of the log message, such as date, time, log level, method, class, and message.

For example, the pattern "%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %logger{36} - %msg%n" represents a PatternLayout where "%d" denotes the date, "%t" denotes the thread name, "%-5level" denotes the log level with a fixed width of 5 characters, "%logger{36}" denotes the logger name limited to 36 characters, "%msg" denotes the log message, and "%n" denotes a new line.

By configuring the PatternLayout, you can customize the appearance and content of log messages according to your preferences and logging needs.

In summary, in a Spring Boot application using Log4j 2.x, the logging service plays a crucial role in capturing and managing log messages. The types of log messages help categorize and filter them based on severity and purpose. The logger with priority methods allows for logging messages at different levels of severity. The appender determines where the log messages will be written, and the layout defines the format of the log messages, including the PatternLayout. Configuring the appender and layout can be done using XML or properties files, providing flexibility and customization options for logging in the application.

<br/>
<br/>

# Here's the breakdown of the provided code:

**UserRestController.java - Example Code 1**:
```java
package com.app.rest;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

//@RestController
//@RequestMapping("/users")
public class UserRestController {
	
	private static final Logger LOG = LogManager.getLogger(UserRestController.class);

	//@PostMapping("/save")
	public String saveUser() {
		LOG.info("Entered into User#save Operation ");
		try {
			LOG.warn("May not be a good choice.. But valid for the operation");
			// Some code for save operation
			Integer id = 999;
			LOG.debug("User created with {}",  id);
		} catch(Exception e) {
			LOG.error("Unable to process details {}", e.getMessage());
			e.printStackTrace();
			throw e;
		}
		LOG.info("About to leave Save Operation");
		return "SUCCESS";
	}
}
```

**Explanation - UserRestController.java - Example Code 1**:
The `UserRestController` class is a sample Spring REST controller responsible for handling user-related operations. Here's an explanation of the code:

- The class is commented out with `//@RestController` and `//@RequestMapping("/users")`, which indicates that it is not currently active as a REST controller and does not have a base request mapping.
- The class defines a logger named `LOG` using Log4j's `LogManager.getLogger(UserRestController.class)`. This logger is used to log messages throughout the class.
- The `saveUser()` method is a hypothetical endpoint for saving user details.
- Inside the method, various log statements are used to log different types of messages:
  - `LOG.info("Entered into User#save Operation ")`: Logs an informational message indicating the entry into the `saveUser()` operation.
  - `LOG.warn("May not be a good choice.. But valid for the operation")`: Logs a warning message indicating that the chosen approach may not be ideal but is still valid for the operation.
  - Some code for the save operation is assumed to be present but is not provided in the code snippet.
  - `LOG.debug("User created with {}",  id)`: Logs a debug message indicating the successful creation of a user. The `{}` is a placeholder for the `id` variable, allowing its value to be included in the log message.
  - In case of an exception during the process, an `Exception` object is caught and logged using `LOG.error("Unable to process details {}", e.getMessage())`. The exception stack trace is also printed to the console using `e.printStackTrace()`.
  - The exception is then re-thrown to propagate it up the call stack.
  - `LOG.info("About to leave Save Operation")`: Logs an informational message indicating the departure from the `saveUser()` operation.
- The method returns a string value "SUCCESS" to indicate a successful execution of the operation.

This example showcases how log messages can be used to track the flow and status of operations within a Spring REST controller.

**UserRestController.java - Example Code 2**:
```java
package com.app.shivam.rest;

import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import lombok.extern.slf4j.Slf4j;

@RestController
@RequestMapping("/users")
@Slf4j
public class UserRestController {
	
	//private static final Logger log = LogManager.getLogger(UserRestController.class);

	@PostMapping("/save")
	public String saveUser() {
		log.info("Entered into User#save Operation ");
		try {
			log.warn("May not be a good choice.. But valid for the operation");
			// Some code for save operation
			Integer id = 999;
			log.debug("User created with {}",  id);
		} catch(Exception e) {
			log.error("Unable to process details {}", e.getMessage());
			e.printStackTrace();
			throw e;
		}
		log.info("About to leave Save Operation");
		return "SUCCESS";
	}
}
```

**Explanation - UserRestController.java - Example Code 2**:
The second example of the `UserRestController` class is similar to the first one, with a few differences:

- The class is annotated with `@RestController` and `@RequestMapping("/users")`, indicating that it functions as a Spring REST controller with a base request mapping of "/users".
- The class uses the Lombok `@Slf4j` annotation to automatically generate a logger named `log`. This logger is used throughout the class to log messages.
- The code and log statements inside the `saveUser()` method are identical to the first example. They follow the same pattern of logging messages at different levels.
- The only significant difference is the usage of the `log` logger instead of the `LOG` logger from Log4j.

This example demonstrates an alternative approach using Lombok's `@Slf4j` annotation to generate a logger automatically, reducing the need for manual logger initialization.

**Conclusion**:
In conclusion, both examples provide a demonstration of a Spring REST controller class named `UserRestController` with a hypothetical save user operation. The examples highlight the usage of logging statements using Log4j and the alternative approach using Lombok's `@Slf4j` annotation for automatic logger generation. Log statements at different log levels are used to capture the flow and status of the operation. These examples illustrate how logging can be integrated into a Spring Boot application to monitor and track the behavior of REST endpoints.

# **`slf4j`**


**SLF4J (Simple Logging Facade for Java)**:
SLF4J is an abstract framework designed to provide a simple facade or API for various logging frameworks such as Log4j, Commons Logging, and Java Util Logging. It allows developers to write logging code in a generic manner, decoupled from any specific logging implementation. By using SLF4J, you can switch between different logging frameworks without changing your code.

When using SLF4J, you typically add a logger object to your class using the line `private static final Logger log = LoggerFactory.getLogger(__.class);`. The `__` should be replaced with the name of the class where the logger is defined. This logger object can be used to log messages at various levels (debug, info, warn, error, etc.) throughout the class.

**Project Lombok and SLF4J**:
Project Lombok is a library that helps reduce boilerplate code in Java classes. It provides annotations that automatically generate code during compilation. To generate the SLF4J logger object, you can simply add the `@Slf4j` annotation to your class. Lombok will automatically generate the logger object line for you. This eliminates the need to manually add the logger object using the `LoggerFactory.getLogger(__.class)` method call.

**Spring Boot Logging Dependency**:
When you create a Spring Boot application and add dependencies to your project, the `spring-boot-starter-logging` dependency is automatically added by default. This dependency brings logging support to your Spring Boot application. It includes support for Logback, Log4J, and Java Util Logging (JUL). Spring Boot provides a consistent and customizable logging experience by allowing you to configure the logging framework according to your preferences.

**RollingFileAppender**:
In the context of logging, the RollingFileAppender is a configuration option that specifies how log files should be managed. It allows you to configure the behavior of log files when they reach a maximum size limit. When a log file exceeds the limit, a backup of the file is created in a compressed format (such as ZIP). The backup file is then typically moved to an archival service for long-term storage and retrieval.

**BASH_SCRIPT and AWS S3 Glacier**:
The reference to BASH_SCRIPT and AWS S3 Glacier suggests a process of using a BASH script, in combination with the AWS SDK API, to upload log files to AWS S3 Glacier. AWS S3 Glacier is a storage service provided by Amazon Web Services (AWS) that offers secure, durable, and cost-effective long-term storage for data archives.

The BASH script is responsible for compressing the log files into a `.tar.gz` format (tarball with gzip compression). The AWS SDK API is used to interact with the AWS S3 Glacier service, allowing the script to upload the compressed log files to a Glacier vault for archival purposes. This process helps ensure that log files are securely stored and preserved for future reference or compliance requirements.

In summary, SLF4J provides a simple facade for various logging frameworks, allowing you to switch between different logging implementations. Project Lombok simplifies the generation of SLF4J logger objects by automatically generating the necessary code. The `spring-boot-starter-logging` dependency in Spring Boot brings logging support to your application, including Logback, Log4J, and JUL. The RollingFileAppender configuration option manages log files by creating backups when they reach a maximum size. The reference to BASH_SCRIPT and AWS S3 Glacier suggests using a BASH script and the AWS SDK API to upload log files to AWS S3 Glacier for long-term archival.