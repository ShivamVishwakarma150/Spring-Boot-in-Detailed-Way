# Distributed Tracing with Sleuth and Zipkin

Distributed tracing is a technique used in distributed systems to track and monitor the flow of requests as they traverse through multiple microservices. It provides insights into the execution path, timing, and interactions between various services involved in processing a single request. In the given example flow, we can see that a request, Req#1, goes through several microservices (MS#1, MS#2, MS#3) before returning a response, Resp#1.

Here's a detailed explanation of the points you mentioned:

**1. Number of microservices called:**
   Distributed tracing allows you to determine the number of microservices involved in processing a particular request. In the given example, the request Req#1 is processed by multiple microservices, including MS#1, MS#2, and MS#3.

**2. Execution path (method->method):**
   Distributed tracing captures the execution path or the sequence of method calls that occur across different microservices during request processing. It helps you understand the flow of control and the sequence in which services are invoked. For example, in the given flow, the execution path can be represented as follows:
   Req#1 -> API Gateway -> Eureka -> Gateway -> MS#1 -> MS#2 -> MS#3 -> MS#2 -> MS#1 -> Gateway -> Resp#1

**3. Time taken for exact service and all services:**
   Distributed tracing provides timing information about the execution of each service and the overall request processing time. It allows you to identify the time taken by individual services as well as the cumulative time across all services involved in request processing. This information helps in troubleshooting performance issues and identifying bottlenecks. By instrumenting the code in each microservice, the tracing system can measure the time spent in each service and provide aggregated timing information for the complete request. The timing information can include the time taken in processing, network latency, and other relevant factors.

Spring Cloud provides two main components for distributed tracing: Sleuth and Zipkin.

Sleuth:
Sleuth is a distributed tracing solution provided by Spring Cloud. It generates tracing information and instrumentation for your application. It assigns a unique identifier, called a trace ID, to each request and propagates it through different services. Sleuth also generates span IDs, which represent individual operations within a trace, and logs timing information for each span. By using Sleuth, you can collect tracing data and gain insights into the execution flow and timing of your application's requests.

**Zipkin:**
Zipkin is a distributed tracing system that stores and displays the tracing data collected by Sleuth. It provides a web interface where you can visualize the tracing information, including the execution path, timing, and dependencies between services. Zipkin aggregates and stores the spans generated by Sleuth, allowing you to search, analyze, and troubleshoot distributed system performance. It helps in identifying latency issues, understanding service dependencies, and optimizing the overall system performance.

**Eureka Server:**
Eureka is a service registry provided by Spring Cloud. It is used for service discovery and registration. Eureka Server stores information about the running instances of services, such as the number of microservices (instances) available, their IP addresses, ports, and other metadata. It helps in locating and load balancing requests across multiple instances of a service.

In summary, distributed tracing, facilitated by Sleuth and Zipkin, allows you to track the flow of requests, identify the number of microservices involved, understand the execution path, and measure the timing of each service and the overall request processing time. It is a powerful debugging and performance analysis tool for distributed systems.

<br/>
<br/>

# **Zipkin Server**:

The Zipkin server plays a crucial role in distributed tracing by storing and managing the tracing data collected by Sleuth. It provides a web interface where you can analyze and visualize the tracing information. Let's address your specific questions:

1. **How many requests processed?**
   The Zipkin server keeps track of the requests processed by recording and storing the spans generated by Sleuth. Each span represents a single operation within a trace. By querying the Zipkin server, you can determine the number of requests processed within a given timeframe.

2. **Execution Path:**
   The Zipkin server retains the execution path information captured by Sleuth. It allows you to reconstruct the sequence of method calls across multiple microservices involved in processing a request. By analyzing the spans stored in Zipkin, you can derive the execution path and understand the flow of control in your distributed system.

3. **How many microservices called?**
   By inspecting the spans recorded in Zipkin, you can identify the number of microservices (MS#) involved in the processing of a request. Each span represents an individual operation within a trace, which corresponds to a microservice. Therefore, by counting the number of spans associated with a specific trace ID, you can determine the number of microservices invoked during the request processing.

4. **How much time taken?**
   Zipkin captures the timing information for each span recorded by Sleuth. This includes the time taken by individual microservices, as well as the cumulative time across all microservices involved in request processing. By analyzing the timestamps associated with the spans, you can calculate the elapsed time for each microservice and the overall time taken for request processing. This helps in identifying performance bottlenecks, optimizing system performance, and troubleshooting latency issues.

In summary, the Zipkin server acts as a central repository for tracing data, providing capabilities to analyze and visualize the execution path, timing information, and the number of microservices involved in processing requests. By leveraging Zipkin in conjunction with Sleuth, you gain valuable insights into the behavior and performance of your distributed system.

<br/>
<br/>

## **To download and test the Zipkin Server, follow the steps below:**

1. Go to the following URL: [https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/2.12.9/](https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/2.12.9/)

2. Click on the file `zipkin-server-2.12.9-exec.jar` to download it.

3. Open your command prompt or terminal and navigate to the directory where the downloaded JAR file is located.

4. Execute the following command to start the Zipkin Server:
```
java -jar zipkin-server-2.12.9-exec.jar
```

5. Once the Zipkin Server is running, open your web browser and enter the URL [http://127.0.0.1:9411/zipkin/](http://127.0.0.1:9411/zipkin/).


# **We need to define two microservices (MS#) that are connected using any one client. There are several options for achieving this connectivity, including:**

- **DiscoveryClient / LoadBalancerClient [manual code]:**
   You can manually write code to use Spring Cloud's `DiscoveryClient` or `LoadBalancerClient` to discover and load balance requests between the microservices. These clients allow you to dynamically locate and interact with the desired microservice instances.

- **Open Feign (Abstract client):**
   Open Feign is a declarative web service client provided by Spring Cloud. It simplifies the process of invoking remote services by generating proxy clients based on interfaces annotated with `@FeignClient`. It integrates well with service discovery mechanisms and provides load balancing out-of-the-box.

- **RestTemplate:**
   `RestTemplate` is a traditional synchronous HTTP client provided by Spring Framework. It supports communication between microservices and is suitable for non-Java applications as well. You can manually configure it to make requests to the desired microservices.

- **WebClient:**
   `WebClient` is a non-blocking, reactive web client provided by Spring WebFlux. It is suitable for building reactive applications and supports communication with microservices. You can use `WebClient` to make requests to the desired microservices.

To establish connectivity between the microservices, you need to add the following dependencies to the respective microservice applications:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-zipkin-client</artifactId>
</dependency>
```

These dependencies ensure that the microservices are instrumented with Sleuth and can communicate with the Zipkin Server for distributed tracing purposes.

In summary, you can download and test the Zipkin Server by following the provided steps. Additionally, you can establish connectivity between microservices using various options such as DiscoveryClient/LoadBalancerClient, Open Feign, RestTemplate, or WebClient. By adding the necessary Sleuth and Zipkin dependencies, you enable distributed tracing capabilities in your microservice applications.